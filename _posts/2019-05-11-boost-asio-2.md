

#boost asio ??(??)

[ toc ]
-----

boost::asio “??????????I / O??????C ++???????C ++?????????????????”??????????????????????????????boost::asio???????????????????????????????????????boost::asio??????; ?????????

???????????????????????????????????C ++??????boost?????boost::asio?????????????????????????????????????????boost::asio?????????????????????????????????????boost::asio?????????????????????????????????????????? 

### ??
- io_service?????
- ??boost :: bind
- ?io_service????????
- ??strand??????????
- ????
- ???
- ?????????????TCP?
- ????????????????TCP?
- boost::asio??????TCP?
- ????


-----
### io_service?????
boost::asio??????io_service????????????????????????????????????????????????run?????????????????“run?????????????????????????????????????io_service????”

#### ?1a (run io_service )
```
int main( int argc, char * argv[] )
{
	boost::asio::io_service io_service;
	//????
	io_service.run();
	std::cout << "?????????????" << std::endl;
	return 0;
}
```

?????????????????????????????????????????????????????????????????????????????

**????????????????????; ????????**

???????????????????????????????????; boost::asio??????????????????????????????boost::asio???????????????????????????????????????“???io_service???????????”??????????io_service??????????????????????????????????????????

?1b  
 ?????????? ????????

```
int main( int argc, char * argv[] )
{
	boost::asio::io_service io_service;
	boost::asio::io_service::work work( io_service );
	// ??work???? ???? ??????????
	io_service.run();
	std::cout << "?????????????" << std::endl;
	return 0;
}
```


**?????????? ???????????? ????????????????** 
??????????????????????????????????????????????????????????????????????

?????????????????boost::asio?????????????????????????????????????????????????????????????????????????????????

?????????????????????io_service?poll???poll??“??io_service???????????????????”

?1c


#include 
#include 

int main( int argc, char * argv[] )
{
	boost::asio::io_service io_service;

	for( int x = 0; x < 42; ++x )
	{
		io_service.poll();
		std::cout << "Counter: " << x << std::endl;
	}

	return 0;
}

???????????????42?????????????????????????????io_service?????????????

?1d


#include 
#include 

int main( int argc, char * argv[] )
{
	boost::asio::io_service io_service;
	boost::asio::io_service::work work( io_service );

	for( int x = 0; x < 42; ++x )
	{
		io_service.poll();
		std::cout << "Counter: " << x << std::endl;
	}

	return 0;
}

???????????????????????????????????????????poll?????????????????????????????????????????????????????????????

???????????????????????????????io_service????????????????????io_service???????????????????????????????????????????????????????????????????????????

???????????????????????run?poll??????????????run_one?poll_one??????????????????????????????????????????????????????io_service????????????run?poll??????????poll????????????run??????????????????????????

????????????????????????io_service?????????????????????????????????????????????????????????boost???????shared_ptr?????????

?1e


int main( int argc, char * argv[] )
{
	boost::asio::io_service io_service;
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( io_service )
	);

	work.reset();

	io_service.run();

	std::cout << "?????????????" << std::endl;

	return 0;	
}

??????????????????????????????????io_service???????????????????????????????????????????????????????????????????

???????????????io_service?????????????????io_service????????“????????run?????????????io_service???????????????????????????io_service??????????????????“??????????boost?????????????????????????

?1f

boost::asio::io_service io_service;

void WorkerThread()
{
	std::cout << "Thread Start\n";
	io_service.run();
	std::cout << "Thread Finish\n";
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( io_service )
	);

	std::cout << "Press [return] to exit." << std::endl;

	boost::thread_group worker_threads;
	for( int x = 0; x < 4; ++x )
	{
		worker_threads.create_thread( WorkerThread );
	}

	std::cin.get();

	io_service.stop();

	worker_threads.join_all();

	return 0;
}
??????stop???????????io_service????????????????????????????????????????????????io_service?????????????????????????????????????????????????????4??????????????????????????????????

???????????????????????????????????????????????io_service???????????????????????????????io_service????????????????????????stop????????????????????????????????????io_service?????????????????????????????????????stop????????????

???????????io_service??????????????????????????????????????????

[?]

??boost :: bind
????????io_service???????????????????boost?boost :: bind????????????boost :: bind????????????????????????????????boost::asio??????????????????????????????????????boost :: bind?????????????????

??boost :: bind??????????????????????

???2a


#include 
#include 

void F1()
{
	std::cout << __FUNCTION__ << std::endl;
}

int main( int argc, char * argv[] )
{
	boost::bind( &F1 );
	return 0;
}

???????????????????????????????????????????????????????????????????

???2b


#include 
#include 

void F1()
{
	std::cout << __FUNCTION__ << std::endl;
}

int main( int argc, char * argv[] )
{
	boost::bind( &F1 )();
	return 0;
}
??????????????????????????????????????????

?2c


#include 
#include 

void F2( int i, float f )
{
	std::cout << "i: " << i << std::endl;
	std::cout << "f: " << f << std::endl;
}

int main( int argc, char * argv[] )
{
	boost::bind( &F2, 42, 3.14f )();
	return 0;
}
??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????boost :: bind????????????????????????????????

???boost :: bind??????????????????????bind??????????????????????

?2d


#include 
#include 

class MyClass
{
public:
	void F3( int i, float f )
	{
		std::cout << "i: " << i << std::endl;
		std::cout << "f: " << f << std::endl;
	}
};

int main( int argc, char * argv[] )
{
	MyClass c;
	boost::bind( &MyClass::F3, &c, 42, 3.14f )();
	return 0;
}
????????????????????????????????bind?????????this????????shared_from_this??????????????????????????????????????????????????????boost :: bind?????????????????????????????????????????boost :: bind?????????????

?????????boost :: bind????????????????????boost::asio????io_service??????????????????????????????????????????????????io_service?boost :: bind??????????????????????????io_service????boost :: bind???????????????????????????shared_ptr?

??????io_service?shared_ptr???????????????io_service???shared_ptr?????????????????????????boost :: bind????????????????????; ???????????????shared_ptrs?????????????????????????????

?2e


#include 
#include 
#include 
#include 
#include 

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	std::cout << "Thread Start\n";
	io_service->run();
	std::cout << "Thread Finish\n";
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);

	std::cout << "Press [return] to exit." << std::endl;

	boost::thread_group worker_threads;
	for( int x = 0; x < 4; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	std::cin.get();

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
???????????io_service???shared_ptr??????????????????????????????????????????????????????????????????????????????boost :: bind?shared_ptr????????boost::asio???????????????????????????

??????????????????????????????????????????????????????????????std :: cout?????????????????????????????????????????????????????????????????????????boost :: thread?????????????????

???????????????????????????????????????????????????????????????boost :: thread???id?????????????????????????????????

?2f


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id() << 
		"] Thread Start" << std::endl;
	global_stream_lock.unlock();

	io_service->run();

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id() <<
		"] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id() 
		<< "] Press [return] to exit." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 4; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	std::cin.get();

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
??????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

???????????????????????boost :: bind??????????????????????????????Boost Bind???????C ++?????C ++???Boost.Function'drop-in'??????Boost :: bind???????????????????????????????????

[?]

?io_service????????
????????????????????????????????????????????????io_service?boost::asio??????????io_service?????post?dispatch??arm?legs?post??“????io_service??????????????io_service?????????????”dispatch??“?????????????????????????run_one???poll???poll_one???????????????????????????????“

???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????post?????

??????????????Fibonacci??????????????????????????????boost::asio????????????????????2?????????????????????????????????????????

???3a


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	io_service->run();

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

size_t fib( size_t n )
{
	if ( n <= 1 )
	{
		return n;
	}
	boost::this_thread::sleep( 
		boost::posix_time::milliseconds( 1000 )
	);
	return fib( n - 1 ) + fib( n - 2);
}

void CalculateFib( size_t n )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Now calculating fib( " << n << " ) " << std::endl;
	global_stream_lock.unlock();

	size_t f = fib( n );

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] fib( " << n << " ) = " << f << std::endl;
	global_stream_lock.unlock();
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] The program will exit when all work has finished."
		<< std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( 
			boost::bind( &WorkerThread, io_service )
		);
	}

	io_service->post( boost::bind( CalculateFib, 3 ) );
	io_service->post( boost::bind( CalculateFib, 4 ) );
	io_service->post( boost::bind( CalculateFib, 5 ) );

	work.reset();

	worker_threads.join_all();

	return 0;
}
????????main???????post???3????????io_service????????????????????io_service run?poll???dispatch????post????????????????post??io_service??????????????????????????????????????????????????????join_all?????

???fib????????????????????????????????????????????????CalculateFib??????????????????????????????????????????

?????????????????????????????????????????????????????????????????

??????????????????????????????boost::asio??????????????????????????????????????????????io_service????????????????????????????????

????????????post?dispatch???????????????????????????????????????????????

???3b


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	io_service->run();

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void Dispatch( int x )
{
	global_stream_lock.lock();
	std::cout << "[" <<  boost::this_thread::get_id()  << "] " 
		<< __FUNCTION__  << " x = " << x <<  std::endl;
	global_stream_lock.unlock();
}

void Post( int x )
{
	global_stream_lock.lock();
	std::cout << "[" <<  boost::this_thread::get_id()  << "] " 
		<< __FUNCTION__  << " x = " << x <<  std::endl;
	global_stream_lock.unlock();
}

void Run3( boost::shared_ptr< boost::asio::io_service > io_service )
{
	for( int x = 0; x < 3; ++x )
	{
		io_service->dispatch( boost::bind( &Dispatch, x * 2 ) );
		io_service->post( boost::bind( &Post, x * 2 + 1 ) );
		boost::this_thread::sleep( boost::posix_time::milliseconds( 1000 ) );
	}
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service( 
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);

	global_stream_lock.lock();
	std::cout << "[" <<  boost::this_thread::get_id()  
		<< "] The program will exit when all  work has finished." <<  std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 1; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	io_service->post( boost::bind( &Run3, io_service ) );

	work.reset();

	worker_threads.join_all();

	return 0;
}
????????????????????????????????????????????????dispatch??????????????????????????????????????????????????????????????????????????????????????????????????????????????

?????????????????????????????????????????????????????????????????????????????????????????????????????????????????0,2,1,4,3,5??????????????????????????????“??”???????????????????????????????????????????????????????????????????API?

?????????????????????????????io_service??????????????????????????????????????????????????????????????????????????????????????boost::asio?????????

[?]

??strand??????????
??????????????????????????????????????strand??strand?“?????????????”????????????strand??work1 - > work2 - > work3??????????????????????????

???????????????? ??????strand????????????[quote]??????????????strand????????????????????????a1?????????????????b??????????????b1?????????b??????????????????s.post?a????s.post?b?s.post?a????? - ???s.dispatch?b?????????s.dispatch?a????? - ?s.post?b???????????s.dispatch?a????? - ?s.dispatch?b????????????stra??????asio_handler_invoke?a1??

???????????

async_op_1?...?s.wrap?a??; async_op_2?...?s.wrap?b??; ?????????????s.dispatch?a????????s.dispatch?b????????????????????????????????????????????????????????????[/ quote]

???strand???????????????????????????????????????????????????????????????????????????????????????????????????????????

???????????????strand?????????std :: cout????????

???4a


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	io_service->run();

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void PrintNum( int x )
{
	std::cout << "[" << boost::this_thread::get_id()
		<< "] x: " << x << std::endl;
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service( 
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);
	boost::asio::io_service::strand strand( *io_service );

	global_stream_lock.lock();
	std::cout << "[" <<  boost::this_thread::get_id()  
		<< "] The program will exit when all  work has finished." <<  std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::this_thread::sleep( boost::posix_time::milliseconds( 1000 ) );

	//strand.post( boost::bind( &PrintNum, 1 ) );
	//strand.post( boost::bind( &PrintNum, 2 ) );
	//strand.post( boost::bind( &PrintNum, 3 ) );
	//strand.post( boost::bind( &PrintNum, 4 ) );
	//strand.post( boost::bind( &PrintNum, 5 ) );

	io_service->post( boost::bind( &PrintNum, 1 ) );
	io_service->post( boost::bind( &PrintNum, 2 ) );
	io_service->post( boost::bind( &PrintNum, 3 ) );
	io_service->post( boost::bind( &PrintNum, 4 ) );
	io_service->post( boost::bind( &PrintNum, 5 ) );

	work.reset();

	worker_threads.join_all();

	return 0;
}

??????????


[00154F88] The program will exit when all work has finished.
[001532B0] Thread Start
[00154FB0] Thread Start
[[001532B000154FB0] x: ] x: 21

[[001532B000154FB0] x: ] x: 34

[001532B0] x: 5
[00154FB0] Thread Finish
[001532B0] Thread Finish
Press any key to continue . . .
????????????????std :: cout????????????????????????????????????????PC????????????????????????????????????????????????????????????????????

??????????????????????io_service-> post?????strand.post???????strand????????


[00154F88] The program will exit when all work has finished.
[001532B0] Thread Start
[00154FB0] Thread Start
[001532B0] x: 1
[00154FB0] x: 2
[001532B0] x: 3
[00154FB0] x: 4
[001532B0] x: 5
[00154FB0] Thread Finish
[001532B0] Thread Finish
Press any key to continue . . .
??????????????????????x????????????strand??????????????????????????????????????strand????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

???????????????????????????????????????????????????????????????????????????????????

???4b


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id() << "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	io_service->run();

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void PrintNum( int x )
{
	std::cout << "[" << boost::this_thread::get_id() 
		<< "] x: " << x << std::endl;
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);
	boost::asio::io_service::strand strand( *io_service );

	global_stream_lock.lock();
	std::cout << "[" <<  boost::this_thread::get_id()  
		<< "] The program will exit when all  work has finished." <<  std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 4; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::this_thread::sleep( boost::posix_time::milliseconds( 100 ) );
	io_service->post( strand.wrap( boost::bind( &PrintNum, 1 ) ) );
	io_service->post( strand.wrap( boost::bind( &PrintNum, 2 ) ) );

	boost::this_thread::sleep( boost::posix_time::milliseconds( 100 ) );
	io_service->post( strand.wrap( boost::bind( &PrintNum, 3 ) ) );
	io_service->post( strand.wrap( boost::bind( &PrintNum, 4 ) ) );

	boost::this_thread::sleep( boost::posix_time::milliseconds( 100 ) );
	io_service->post( strand.wrap( boost::bind( &PrintNum, 5 ) ) );
	io_service->post( strand.wrap( boost::bind( &PrintNum, 6 ) ) );

	work.reset();

	worker_threads.join_all();

	return 0;
}
???????????????????????1,2,3,4,5,6??????????????????????????2,1,3,4,5,6??????????????????????????????????????????????????????????????????????????????????????????API?????????????????

?????????????????strand??API??????????????????io_service????????strand?????????????????????????????????????????????????????????????????????????????????????????????????strand wrap????????

??????strand??????????????????????????????????????????????????????????

????????????????boost::asio???????boost::asio???????????????

[?]

????
??????????????????????????????????????????boost::asio????????????????????????????????run?poll?????????????try / switch?????????????????????????boost????????????????????????????????????????

??????????????

???5a


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	try
	{
		io_service->run();
	}
	catch( std::exception & ex )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Exception: " << ex.what() << std::endl;
		global_stream_lock.unlock();
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void RaiseAnException( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] " << __FUNCTION__ << std::endl;
	global_stream_lock.unlock();

	io_service->post( boost::bind( &RaiseAnException, io_service ) );

	throw( std::runtime_error( "Oops!" ) );
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
		);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
		);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id() 
		<< "] The program will exit when all work has finished." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	io_service->post( boost::bind( &RaiseAnException, io_service ) );

	worker_threads.join_all();

	return 0;
}
??????????????io_service???????????????????????io_service???????????????????????????????????????run???????????????????????????????join_all??????????????????????????????????????????????????????????

??????????????????

?5b


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	boost::system::error_code ec;
	io_service->run( ec );

	if( ec )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Exception: " << ec << std::endl;
		global_stream_lock.unlock();
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void RaiseAnException( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] " << __FUNCTION__ << std::endl;
	global_stream_lock.unlock();

	io_service->post( boost::bind( &RaiseAnException, io_service ) );

	throw( std::runtime_error( "Oops!" ) );
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
		);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
		);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id() 
		<< "] The program will exit when all work has finished." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	io_service->post( boost::bind( &RaiseAnException, io_service ) );

	worker_threads.join_all();

	return 0;
}
???????????????????????????????????????????????????????????????????boost::asio?????????????????????io_service????????????????C ++?????????boost::asio???????????????????????????????????????????????????????????

???????????????io_service???????????????????????????????????io_service??boost::asio??????????????????????????io_service??boost::asio???????????????????????????????????????????????????????????????????

?????????????????????????????????????????????????????????????????????????????????????????????????io_service?stop?????????????????????????????????????????????????????????run????????????????????????

?5c


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	while( true )
	{
		try
		{
			boost::system::error_code ec;
			io_service->run( ec );
			if( ec )
			{
				global_stream_lock.lock();
				std::cout << "[" << boost::this_thread::get_id()
					<< "] Error: " << ec << std::endl;
				global_stream_lock.unlock();
			}
			break;
		}
		catch( std::exception & ex )
		{
			global_stream_lock.lock();
			std::cout << "[" << boost::this_thread::get_id()
				<< "] Exception: " << ex.what() << std::endl;
			global_stream_lock.unlock();
		}
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void RaiseAnException( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] " << __FUNCTION__ << std::endl;
	global_stream_lock.unlock();

	io_service->post( boost::bind( &RaiseAnException, io_service ) );

	throw( std::runtime_error( "Oops!" ) );
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
		);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
		);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id() 
		<< "] The program will exit when all work has finished." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	io_service->post( boost::bind( &RaiseAnException, io_service ) );

	worker_threads.join_all();

	return 0;
}
?????????????????????????????stop?????????????run????????????????????????????????????????????????????????????????????????????????????????????????????

????boost::asio????????????????I / O?????????????????????????????????boost::asio???????????

[?]

???
boost::asio???deadline_timer?????????????????????????????????????????boost::asio???????????????

???????????????????5?????????????????????????????????????

???6a


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	while( true )
	{
		try
		{
			boost::system::error_code ec;
			io_service->run( ec );
			if( ec )
			{
				global_stream_lock.lock();
				std::cout << "[" << boost::this_thread::get_id()
					<< "] Error: " << ec << std::endl;
				global_stream_lock.unlock();
			}
			break;
		}
		catch( std::exception & ex )
		{
			global_stream_lock.lock();
			std::cout << "[" << boost::this_thread::get_id()
				<< "] Exception: " << ex.what() << std::endl;
			global_stream_lock.unlock();
		}
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void TimerHandler( const boost::system::error_code & error )
{
	if( error )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Error: " << error << std::endl;
		global_stream_lock.unlock();
	}
	else
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] TimerHandler " << std::endl;
		global_stream_lock.unlock();
	}
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
		);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
		);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Press [return] to exit." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::asio::deadline_timer timer( *io_service );
	timer.expires_from_now( boost::posix_time::seconds( 5 ) );
	timer.async_wait( TimerHandler );

	std::cin.get();

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
??????????????????????????????????????????????????????????????boost :: bind???????????shared_ptr???timer?????????boost :: bind??????????????????????????????????????

?6b


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	while( true )
	{
		try
		{
			boost::system::error_code ec;
			io_service->run( ec );
			if( ec )
			{
				global_stream_lock.lock();
				std::cout << "[" << boost::this_thread::get_id()
					<< "] Error: " << ec << std::endl;
				global_stream_lock.unlock();
			}
			break;
		}
		catch( std::exception & ex )
		{
			global_stream_lock.lock();
			std::cout << "[" << boost::this_thread::get_id()
				<< "] Exception: " << ex.what() << std::endl;
			global_stream_lock.unlock();
		}
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void TimerHandler(
	const boost::system::error_code & error,
	boost::shared_ptr< boost::asio::deadline_timer > timer
)
{
	if( error )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Error: " << error << std::endl;
		global_stream_lock.unlock();
	}
	else
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] TimerHandler " << std::endl;
		global_stream_lock.unlock();

		timer->expires_from_now( boost::posix_time::seconds( 5 ) );
		timer->async_wait( boost::bind( &TimerHandler, _1, timer ) );
	}
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Press [return] to exit." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::shared_ptr< boost::asio::deadline_timer > timer(
		new boost::asio::deadline_timer( *io_service )
	);
	timer->expires_from_now( boost::posix_time::seconds( 5 ) );
	timer->async_wait( boost::bind( &TimerHandler, _1, timer ) );

	std::cin.get();

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
???????boost :: bind???????????????_1???????????TimerHandler????????????????bind????????????_1??“???????????”??????????????????

??????????????5?????????????????????????????????????????????????boost :: bind???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

?????????????strand?????????strand????????????????????????????????????????????????????????????????

?6c


#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	while( true )
	{
		try
		{
			boost::system::error_code ec;
			io_service->run( ec );
			if( ec )
			{
				global_stream_lock.lock();
				std::cout << "[" << boost::this_thread::get_id() 
					<< "] Error: " << ec << std::endl;
				global_stream_lock.unlock();
			}
			break;
		}
		catch( std::exception & ex )
		{
			global_stream_lock.lock();
			std::cout << "[" << boost::this_thread::get_id()
				<< "] Exception: " << ex.what() << std::endl;
			global_stream_lock.unlock();
		}
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void TimerHandler(
	const boost::system::error_code & error, 
	boost::shared_ptr< boost::asio::deadline_timer > timer, 
	boost::shared_ptr< boost::asio::io_service::strand > strand
)
{
	if( error )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Error: " << error << std::endl;
		global_stream_lock.unlock();
	}
	else
	{
		std::cout << "[" << boost::this_thread::get_id()
			<< "] TimerHandler " << std::endl;

		timer->expires_from_now( boost::posix_time::seconds( 1 ) );
		timer->async_wait( 
			strand->wrap( boost::bind( &TimerHandler, _1, timer, strand ) )
		);
	}
}

void PrintNum( int x )
{
	std::cout << "[" << boost::this_thread::get_id()
		<< "] x: " << x << std::endl;
	boost::this_thread::sleep( boost::posix_time::milliseconds( 1000 ) );
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);
	boost::shared_ptr< boost::asio::io_service::strand > strand(
		new boost::asio::io_service::strand( *io_service )
	);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Press [return] to exit." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::this_thread::sleep( boost::posix_time::seconds( 1 ) );

	strand->post( boost::bind( &PrintNum, 1 ) );
	strand->post( boost::bind( &PrintNum, 2 ) );
	strand->post( boost::bind( &PrintNum, 3 ) );
	strand->post( boost::bind( &PrintNum, 4 ) );
	strand->post( boost::bind( &PrintNum, 5 ) );

	boost::shared_ptr< boost::asio::deadline_timer > timer(
		new boost::asio::deadline_timer( *io_service )
	);
	timer->expires_from_now( boost::posix_time::seconds( 1 ) );
	timer->async_wait( 
		strand->wrap( boost::bind( &TimerHandler, _1, timer, strand ) )
	);

	std::cin.get();

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
????????????????????????????????????????????????????????strand?????????????????????????????????????????????????????????????????????????????????????????strand wrap?????????????????????????????????std :: cout??????????????????????????????????boost::asio?????Time Travel???

????????????bind?strand?shared_ptr??boost::asio?????????????????????????????????????????????boost::asio??????????????

[?]

?????????????TCP?
??????boost::asio???????????TCP???boost::asio????????????boost::asio???????????????????????????????????????API???

???????????????????????????????????????tcp :: socket??????????????????????????????????????????????????????????????????????????????????????tcp :: resolver?

?7a


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	while( true )
	{
		try
		{
			boost::system::error_code ec;
			io_service->run( ec );
			if( ec )
			{
				global_stream_lock.lock();
				std::cout << "[" << boost::this_thread::get_id()
					<< "] Error: " << ec << std::endl;
				global_stream_lock.unlock();
			}
			break;
		}
		catch( std::exception & ex )
		{
			global_stream_lock.lock();
			std::cout << "[" << boost::this_thread::get_id()
				<< "] Exception: " << ex.what() << std::endl;
			global_stream_lock.unlock();
		}
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);
	boost::shared_ptr< boost::asio::io_service::strand > strand(
		new boost::asio::io_service::strand( *io_service )
	);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Press [return] to exit." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::asio::ip::tcp::socket sock( *io_service );

	try
	{
		boost::asio::ip::tcp::resolver resolver( *io_service );
		boost::asio::ip::tcp::resolver::query query( 
			"www.google.com", 
			boost::lexical_cast< std::string >( 80 )
		);
		boost::asio::ip::tcp::resolver::iterator iterator = resolver.resolve( query );
		boost::asio::ip::tcp::endpoint endpoint = *iterator;

		global_stream_lock.lock();
		std::cout << "Connecting to: " << endpoint << std::endl;
		global_stream_lock.unlock();

		sock.connect( endpoint );
	}
	catch( std::exception & ex )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Exception: " << ex.what() << std::endl;
		global_stream_lock.unlock();
	}

	std::cin.get();

	boost::system::error_code ec;
	sock.shutdown( boost::asio::ip::tcp::socket::shutdown_both, ec );
	sock.close( ec );

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
????????Google????????????????????IP????????????????????“netstat -n”???????????TCP??????????????????????????????????????????????????lexical_cast????????????????????????????????????????????????????Daytime.1 - ?boost??????TCP????????

????????????????????????????????????GUI???????????GUI?????????boost::asio??????????????????????????????????boost :: bind?boost :: shared_ptr????????????????????????

?7b


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	while( true )
	{
		try
		{
			boost::system::error_code ec;
			io_service->run( ec );
			if( ec )
			{
				global_stream_lock.lock();
				std::cout << "[" << boost::this_thread::get_id()
					<< "] Error: " << ec << std::endl;
				global_stream_lock.unlock();
			}
			break;
		}
		catch( std::exception & ex )
		{
			global_stream_lock.lock();
			std::cout << "[" << boost::this_thread::get_id()
				<< "] Exception: " << ex.what() << std::endl;
			global_stream_lock.unlock();
		}
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void OnConnect( const boost::system::error_code & ec, boost::shared_ptr< boost::asio::ip::tcp::socket > sock )
{
	if( ec )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Error: " << ec << std::endl;
		global_stream_lock.unlock();
	}
	else
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Connected!" << std::endl;
		global_stream_lock.unlock();
	}
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);
	boost::shared_ptr< boost::asio::io_service::strand > strand(
		new boost::asio::io_service::strand( *io_service )
	);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Press [return] to exit." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::shared_ptr< boost::asio::ip::tcp::socket > sock(
		new boost::asio::ip::tcp::socket( *io_service )
	);

	try
	{
		boost::asio::ip::tcp::resolver resolver( *io_service );
		boost::asio::ip::tcp::resolver::query query( 
			"www.google.com", 
			boost::lexical_cast< std::string >( 80 )
		);
		boost::asio::ip::tcp::resolver::iterator iterator = resolver.resolve( query );
		boost::asio::ip::tcp::endpoint endpoint = *iterator;

		global_stream_lock.lock();
		std::cout << "Connecting to: " << endpoint << std::endl;
		global_stream_lock.unlock();

		sock->async_connect( endpoint, boost::bind( OnConnect, _1, sock ) );
	}
	catch( std::exception & ex )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Exception: " << ex.what() << std::endl;
		global_stream_lock.unlock();
	}

	std::cin.get();

	boost::system::error_code ec;
	sock->shutdown( boost::asio::ip::tcp::socket::shutdown_both, ec );
	sock->close( ec );

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
???????????????????????????????????boost :: shared_ptr????boost::asio?????????????????????????????????????????????boost :: bind??????????????????????????????????????????????????????async_connect???????ConnectHandler?????????????????????????????????[??]

@param handler?????????????
?????????????????
???????????
@code void handler?
const boost :: system :: error_code?error //????
?; @endcode
?????????????
??????????????????
?????????????????????
??:: ASIO :: io_service??::????[/??]
????????????????boost :: bind?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

???????????????????????????????????????????“???”??????tcp :: acceptor??????????????????????????????????????????????boost::asio??????????????????????????????????????????????????????????????????

?7c


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	while( true )
	{
		try
		{
			boost::system::error_code ec;
			io_service->run( ec );
			if( ec )
			{
				global_stream_lock.lock();
				std::cout << "[" << boost::this_thread::get_id()
					<< "] Error: " << ec << std::endl;
				global_stream_lock.unlock();
			}
			break;
		}
		catch( std::exception & ex )
		{
			global_stream_lock.lock();
			std::cout << "[" << boost::this_thread::get_id()
				<< "] Exception: " << ex.what() << std::endl;
			global_stream_lock.unlock();
		}
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void OnAccept( const boost::system::error_code & ec, boost::shared_ptr< boost::asio::ip::tcp::socket > sock )
{
	if( ec )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Error: " << ec << std::endl;
		global_stream_lock.unlock();
	}
	else
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Accepted!" << std::endl;
		global_stream_lock.unlock();
	}
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
	);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
	);
	boost::shared_ptr< boost::asio::io_service::strand > strand(
		new boost::asio::io_service::strand( *io_service )
	);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Press [return] to exit." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::shared_ptr< boost::asio::ip::tcp::acceptor > acceptor(
		new boost::asio::ip::tcp::acceptor( *io_service )
	);
	boost::shared_ptr< boost::asio::ip::tcp::socket > sock(
		new boost::asio::ip::tcp::socket( *io_service )
	);

	try
	{
		boost::asio::ip::tcp::resolver resolver( *io_service );
		boost::asio::ip::tcp::resolver::query query( 
			"127.0.0.1", 
			boost::lexical_cast< std::string >( 7777 )
		);
		boost::asio::ip::tcp::endpoint endpoint = *resolver.resolve( query );
		acceptor->open( endpoint.protocol() );
		acceptor->set_option( boost::asio::ip::tcp::acceptor::reuse_address( false ) );
		acceptor->bind( endpoint );
		acceptor->listen( boost::asio::socket_base::max_connections );
		acceptor->async_accept( *sock, boost::bind( OnAccept, _1, sock ) );

		global_stream_lock.lock();
		std::cout << "Listening on: " << endpoint << std::endl;
		global_stream_lock.unlock();
	}
	catch( std::exception & ex )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Exception: " << ex.what() << std::endl;
		global_stream_lock.unlock();
	}

	std::cin.get();

	boost::system::error_code ec;
	acceptor->close( ec );

	sock->shutdown( boost::asio::ip::tcp::socket::shutdown_both, ec );
	sock->close( ec );

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
???????????????????????????????boost::asio??????????????????????????????????????????????????????????????????????7777????????????“telnet localhost 7777”?????????????OnAccept???

???????????????????????????async_accept???????????????????????????????????????????API????????????????????????????????????????error_code?????????????????????????????????????????????????????????????????????????????????????????????????????

??????????????????????????????????????????????????????????????????????????

[?]

????????????????TCP?
??????????????????????????????????????????????????????????????ascii / unicode???????????????????????????????????????????boost::asio????????????????

???????????????????????????????????????????????????????????????????

basic_stream_socket?

async_read_some - "This function is used to asynchronously read data from the stream socket. The function call always returns immediately."
async_receive - "This function is used to asynchronously receive data from the stream socket. The function call always returns immediately."
async_send - "This function is used to asynchronously send data on the stream socket. The function call always returns immediately."
async_write_some - "This function is used to asynchronously write data to the stream socket. The function call always returns immediately."
receive - "This function is used to receive data on the stream socket. The function call will block until one or more bytes of data has been received successfully, or until an error occurs."
read_some - "This function is used to read data from the stream socket. The function call will block until one or more bytes of data has been read successfully, or until an error occurs."
send - "This function is used to send data on the stream socket. The function call will block until one or more bytes of the data has been sent successfully, or an until error occurs."
write_some - "This function is used to write data to the stream socket. The function call will block until one or more bytes of the data has been written successfully, or until an error occurs."
boost::asio????

async_read - "Start an asynchronous operation to read a certain amount of data from a stream."
async_read_at - "Start an asynchronous operation to read a certain amount of data at the specified offset."
async_read_until - "Start an asynchronous operation to read data into a streambuf until it contains a delimiter, matches a regular expression, or a function object indicates a match."
async_write - "Start an asynchronous operation to write a certain amount of data to a stream."
async_write_at - "Start an asynchronous operation to write a certain amount of data at the specified offset."
read - "Attempt to read a certain amount of data from a stream before returning."
read_at - "Attempt to read a certain amount of data at the specified offset before returning."
read_until - "Read data into a streambuf until it contains a delimiter, matches a regular expression, or a function object indicates a match."
write - "Write a certain amount of data to a stream before returning. "
write_at - "Write a certain amount of data at a specified offset before returning. "
???????????????boost::asio???????????????????????????????????boost::asio??????????????????????????????????????async_write?async_read_some??????async_write????????????????????????????????????????async_read_some??????????????????????????????????????????

???????????IO???????????????7C????????????

?8a


#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

boost::mutex global_stream_lock;

void WorkerThread( boost::shared_ptr< boost::asio::io_service > io_service )
{
	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Start" << std::endl;
	global_stream_lock.unlock();

	while( true )
	{
		try
		{
			boost::system::error_code ec;
			io_service->run( ec );
			if( ec )
			{
				global_stream_lock.lock();
				std::cout << "[" << boost::this_thread::get_id()
					<< "] Error: " << ec << std::endl;
				global_stream_lock.unlock();
			}
			break;
		}
		catch( std::exception & ex )
		{
			global_stream_lock.lock();
			std::cout << "[" << boost::this_thread::get_id()
				<< "] Exception: " << ex.what() << std::endl;
			global_stream_lock.unlock();
		}
	}

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Thread Finish" << std::endl;
	global_stream_lock.unlock();
}

void OnAccept( const boost::system::error_code & ec, boost::shared_ptr< boost::asio::ip::tcp::socket > sock )
{
	if( ec )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Error: " << ec << std::endl;
		global_stream_lock.unlock();
	}
	else
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Accepted!" << std::endl;
		global_stream_lock.unlock();
	}
}

int main( int argc, char * argv[] )
{
	boost::shared_ptr< boost::asio::io_service > io_service(
		new boost::asio::io_service
		);
	boost::shared_ptr< boost::asio::io_service::work > work(
		new boost::asio::io_service::work( *io_service )
		);
	boost::shared_ptr< boost::asio::io_service::strand > strand(
		new boost::asio::io_service::strand( *io_service )
		);

	global_stream_lock.lock();
	std::cout << "[" << boost::this_thread::get_id()
		<< "] Press [return] to exit." << std::endl;
	global_stream_lock.unlock();

	boost::thread_group worker_threads;
	for( int x = 0; x < 2; ++x )
	{
		worker_threads.create_thread( boost::bind( &WorkerThread, io_service ) );
	}

	boost::shared_ptr< boost::asio::ip::tcp::acceptor > acceptor(
		new boost::asio::ip::tcp::acceptor( *io_service )
		);
	boost::shared_ptr< boost::asio::ip::tcp::socket > sock(
		new boost::asio::ip::tcp::socket( *io_service )
		);

	try
	{
		boost::asio::ip::tcp::resolver resolver( *io_service );
		boost::asio::ip::tcp::resolver::query query( 
			"127.0.0.1", 
			boost::lexical_cast< std::string >( 7777 )
			);
		boost::asio::ip::tcp::endpoint endpoint = *resolver.resolve( query );
		acceptor->open( endpoint.protocol() );
		acceptor->set_option( boost::asio::ip::tcp::acceptor::reuse_address( false ) );
		acceptor->bind( endpoint );
		acceptor->listen( boost::asio::socket_base::max_connections );
		acceptor->async_accept( *sock, boost::bind( OnAccept, _1, sock ) );

		global_stream_lock.lock();
		std::cout << "Listening on: " << endpoint << std::endl;
		global_stream_lock.unlock();
	}
	catch( std::exception & ex )
	{
		global_stream_lock.lock();
		std::cout << "[" << boost::this_thread::get_id()
			<< "] Exception: " << ex.what() << std::endl;
		global_stream_lock.unlock();
	}

	std::cin.get();

	boost::system::error_code ec;
	acceptor->close( ec );

	sock->shutdown( boost::asio::ip::tcp::socket::shutdown_both, ec );
	sock->close( ec );

	io_service->stop();

	worker_threads.join_all();

	return 0;
}
?????????????ClientContext??????????????????????????????????IO????????????????????[xx xx]????????[xx ... xx]?????????????????????????????????????telnet??????????????????????????????????

??????????????????????????????????????????????????????send / recv?????????????????????????????????????????????????????????????????????????????????????????????????API?????????????

????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????async_read?????????????????async_read???????????async_read_some????????

?????????????????????????????????????????100?3????????????100?“???????”??????????????async_read_some??????????????????????????????????????????????????????????????????????????????????????????????????HTTP????????????????????????????????????

????????????????????????????????????????????????????????????????????????????????????????????????????boost::asio???TCP???????????????????????????????????????????????????

???????????????????????????????????????????????????????????????????????????????bug?????????????????????????????????????????????????????????

[?]

boost::asio??????TCP?
???????????boost::asio???????TCP?????????????????????????????????????????????????????????????????????

[color =“?ff0000”]?????[/ color]???????????????????????????????????????????????????????????????????????????????????????????????????

????????????????????????????????????????shared_ptr?boost :: bind?????????????????????????????????????????????????

network.h


#pragma once

#ifndef NETWORK_H_
#define NETWORK_H_

//-----------------------------------------------------------------------------

#include 
#include 
#include 
#include 
#include 
#include 
#include 
#include 

//-----------------------------------------------------------------------------

using boost::uint64_t;
using boost::uint32_t;
using boost::uint16_t;
using boost::uint8_t;

using boost::int64_t;
using boost::int32_t;
using boost::int16_t;
using boost::int8_t;

//-----------------------------------------------------------------------------

class Hive;
class Acceptor;
class Connection;

//-----------------------------------------------------------------------------

class Connection : public boost::enable_shared_from_this< Connection >
{
	friend class Acceptor;
	friend class Hive;

private:
	boost::shared_ptr< Hive > m_hive;
	boost::asio::ip::tcp::socket m_socket;
	boost::asio::strand m_io_strand;
	boost::asio::deadline_timer m_timer;
	boost::posix_time::ptime m_last_time;
	std::vector< uint8_t > m_recv_buffer;
	std::list< int32_t > m_pending_recvs;
	std::list< std::vector< uint8_t > > m_pending_sends;
	int32_t m_receive_buffer_size;
	int32_t m_timer_interval;
	volatile uint32_t m_error_state;

protected:
	Connection( boost::shared_ptr< Hive > hive );
	virtual ~Connection();

private:
	Connection( const Connection & rhs );
	Connection & operator =( const Connection & rhs );
	void StartSend();
	void StartRecv( int32_t total_bytes );
	void StartTimer();
	void StartError( const boost::system::error_code & error );
	void DispatchSend( std::vector< uint8_t > buffer );
	void DispatchRecv( int32_t total_bytes );
	void DispatchTimer( const boost::system::error_code & error );
	void HandleConnect( const boost::system::error_code & error );
	void HandleSend( const boost::system::error_code & error,  std::list< std::vector< uint8_t > >::iterator itr );
	void HandleRecv( const boost::system::error_code & error, int32_t actual_bytes );
	void HandleTimer( const boost::system::error_code & error );

private:
	// Called when the connection has successfully connected to the local
	// host.
	virtual void OnAccept( const std::string & host, uint16_t port ) = 0;

	// Called when the connection has successfully connected to the remote
	// host.
	virtual void OnConnect( const std::string & host, uint16_t port ) = 0;

	// Called when data has been sent by the connection.
	virtual void OnSend( const std::vector< uint8_t > & buffer ) = 0;

	// Called when data has been received by the connection. 
	virtual void OnRecv( std::vector< uint8_t > & buffer ) = 0;

	// Called on each timer event.
	virtual void OnTimer( const boost::posix_time::time_duration & delta ) = 0;

	// Called when an error is encountered.
	virtual void OnError( const boost::system::error_code & error ) = 0;

public:
	// Returns the Hive object.
	boost::shared_ptr< Hive > GetHive();

	// Returns the socket object.
	boost::asio::ip::tcp::socket & GetSocket();

	// Returns the strand object.
	boost::asio::strand & GetStrand();

	// Sets the application specific receive buffer size used. For stream 
	// based protocols such as HTTP, you want this to be pretty large, like 
	// 64kb. For packet based protocols, then it will be much smaller, 
	// usually 512b - 8kb depending on the protocol. The default value is
	// 4kb.
	void SetReceiveBufferSize( int32_t size );

	// Returns the size of the receive buffer size of the current object.
	int32_t GetReceiveBufferSize() const;

	// Sets the timer interval of the object. The interval is changed after 
	// the next update is called.
	void SetTimerInterval( int32_t timer_interval_ms );

	// Returns the timer interval of the object.
	int32_t GetTimerInterval() const;

	// Returns true if this object has an error associated with it.
	bool HasError();

	// Binds the socket to the specified interface.
	void Bind( const std::string & ip, uint16_t port );

	// Starts an a/synchronous connect.
	void Connect( const std::string & host, uint16_t port );

	// Posts data to be sent to the connection.
	void Send( const std::vector< uint8_t > & buffer );

	// Posts a recv for the connection to process. If total_bytes is 0, then 
	// as many bytes as possible up to GetReceiveBufferSize() will be 
	// waited for. If Recv is not 0, then the connection will wait for exactly
	// total_bytes before invoking OnRecv.
	void Recv( int32_t total_bytes = 0 );

	// Posts an asynchronous disconnect event for the object to process.
	void Disconnect();
};

//-----------------------------------------------------------------------------

class Acceptor : public boost::enable_shared_from_this< Acceptor >
{
	friend class Hive;

private:
	boost::shared_ptr< Hive > m_hive;
	boost::asio::ip::tcp::acceptor m_acceptor;
	boost::asio::strand m_io_strand;
	boost::asio::deadline_timer m_timer;
	boost::posix_time::ptime m_last_time;
	int32_t m_timer_interval;
	volatile uint32_t m_error_state;

private:
	Acceptor( const Acceptor & rhs );
	Acceptor & operator =( const Acceptor & rhs );
	void StartTimer();
	void StartError( const boost::system::error_code & error );
	void DispatchAccept( boost::shared_ptr< Connection > connection );
	void HandleTimer( const boost::system::error_code & error );
	void HandleAccept( const boost::system::error_code & error, boost::shared_ptr< Connection > connection );

protected:
	Acceptor( boost::shared_ptr< Hive > hive );
	virtual ~Acceptor();

private:
	// Called when a connection has connected to the server. This function 
	// should return true to invoke the connection's OnAccept function if the 
	// connection will be kept. If the connection will not be kept, the 
	// connection's Disconnect function should be called and the function 
	// should return false.
	virtual bool OnAccept( boost::shared_ptr< Connection > connection, const std::string & host, uint16_t port ) = 0;

	// Called on each timer event.
	virtual void OnTimer( const boost::posix_time::time_duration & delta ) = 0;

	// Called when an error is encountered. Most typically, this is when the
	// acceptor is being closed via the Stop function or if the Listen is 
	// called on an address that is not available.
	virtual void OnError( const boost::system::error_code & error ) = 0;

public:
	// Returns the Hive object.
	boost::shared_ptr< Hive > GetHive();

	// Returns the acceptor object.
	boost::asio::ip::tcp::acceptor & GetAcceptor();

	// Returns the strand object.
	boost::asio::strand & GetStrand();

	// Sets the timer interval of the object. The interval is changed after 
	// the next update is called. The default value is 1000 ms.
	void SetTimerInterval( int32_t timer_interval_ms );

	// Returns the timer interval of the object.
	int32_t GetTimerInterval() const;

	// Returns true if this object has an error associated with it.
	bool HasError();

public:
	// Begin listening on the specific network interface.
	void Listen( const std::string & host, const uint16_t & port );

	// Posts the connection to the listening interface. The next client that
	// connections will be given this connection. If multiple calls to Accept
	// are called at a time, then they are accepted in a FIFO order.
	void Accept( boost::shared_ptr< Connection > connection );

	// Stop the Acceptor from listening.
	void Stop();
};

//-----------------------------------------------------------------------------

class Hive : public boost::enable_shared_from_this< Hive >
{
private:
	boost::asio::io_service m_io_service;
	boost::shared_ptr< boost::asio::io_service::work > m_work_ptr;
	volatile uint32_t m_shutdown;

private:
	Hive( const Hive & rhs );
	Hive & operator =( const Hive & rhs );

public:
	Hive();
	virtual ~Hive();

	// Returns the io_service of this object.
	boost::asio::io_service & GetService();

	// Returns true if the Stop function has been called.
	bool HasStopped();

	// Polls the networking subsystem once from the current thread and 
	// returns.
	void Poll();

	// Runs the networking system on the current thread. This function blocks 
	// until the networking system is stopped, so do not call on a single 
	// threaded application with no other means of being able to call Stop 
	// unless you code in such logic.
	void Run();

	// Stops the networking system. All work is finished and no more 
	// networking interactions will be possible afterwards until Reset is called.
	void Stop();

	// Restarts the networking system after Stop as been called. A new work
	// object is created ad the shutdown flag is cleared.
	void Reset();
};

//-----------------------------------------------------------------------------

#endif
network.cpp


#include "network.h"
#include 
#include 
#include 

//-----------------------------------------------------------------------------

Hive::Hive()
: m_work_ptr( new boost::asio::io_service::work( m_io_service ) ), m_shutdown( 0 )
{
}

Hive::~Hive()
{
}

boost::asio::io_service & Hive::GetService()
{
	return m_io_service;
}

bool Hive::HasStopped()
{
	return ( boost::interprocess::detail::atomic_cas32( &m_shutdown, 1, 1 ) == 1 );
}

void Hive::Poll()
{
	m_io_service.poll();
}

void Hive::Run()
{
	m_io_service.run();
}

void Hive::Stop()
{
	if( boost::interprocess::detail::atomic_cas32( &m_shutdown, 1, 0 ) == 0 )
	{
		m_work_ptr.reset();
		m_io_service.run();
		m_io_service.stop();
	}
}

void Hive::Reset()
{
	if( boost::interprocess::detail::atomic_cas32( &m_shutdown, 0, 1 ) == 1 )
	{
		m_io_service.reset();
		m_work_ptr.reset( new boost::asio::io_service::work( m_io_service ) );
	}
}

//-----------------------------------------------------------------------------

Acceptor::Acceptor( boost::shared_ptr< Hive > hive )
: m_hive( hive ), m_acceptor( hive->GetService() ), m_io_strand(  hive->GetService() ), m_timer( hive->GetService() ),  m_timer_interval( 1000 ), m_error_state( 0 )
{
}

Acceptor::~Acceptor()
{
}

void Acceptor::StartTimer()
{
	m_last_time = boost::posix_time::microsec_clock::local_time();
	m_timer.expires_from_now( boost::posix_time::milliseconds( m_timer_interval ) );
	m_timer.async_wait( m_io_strand.wrap( boost::bind( &Acceptor::HandleTimer, shared_from_this(), _1 ) ) );
}

void Acceptor::StartError( const boost::system::error_code & error )
{
	if( boost::interprocess::detail::atomic_cas32( &m_error_state, 1, 0 ) == 0 )
	{
		boost::system::error_code ec;
		m_acceptor.cancel( ec );
		m_acceptor.close( ec );
		m_timer.cancel( ec );
		OnError( error );
	}
}

void Acceptor::DispatchAccept( boost::shared_ptr< Connection > connection )
{
	m_acceptor.async_accept( connection->GetSocket(),  connection->GetStrand().wrap( boost::bind(  &Acceptor::HandleAccept, shared_from_this(), _1, connection ) ) );
}

void Acceptor::HandleTimer( const boost::system::error_code & error )
{
	if( error || HasError() || m_hive->HasStopped() )
	{
		StartError( error );
	}
	else
	{
		OnTimer( boost::posix_time::microsec_clock::local_time() - m_last_time );
		StartTimer();
	}
}

void Acceptor::HandleAccept( const boost::system::error_code & error, boost::shared_ptr< Connection > connection )
{
	if( error || HasError() || m_hive->HasStopped() )
	{
		connection->StartError( error );
	}
	else
	{
		if( connection->GetSocket().is_open() )
		{
			connection->StartTimer();
			if( OnAccept( connection,  connection->GetSocket().remote_endpoint().address().to_string(),  connection->GetSocket().remote_endpoint().port() ) )
			{
				connection->OnAccept(  m_acceptor.local_endpoint().address().to_string(),  m_acceptor.local_endpoint().port() );
			}
		}
		else
		{
			StartError( error );
		}
	}
}

void Acceptor::Stop()
{
	m_io_strand.post( boost::bind( &Acceptor::HandleTimer, shared_from_this(), boost::asio::error::connection_reset ) );
}

void Acceptor::Accept( boost::shared_ptr< Connection > connection )
{
	m_io_strand.post( boost::bind( &Acceptor::DispatchAccept, shared_from_this(), connection ) );
}

void Acceptor::Listen( const std::string & host, const uint16_t & port )
{
	boost::asio::ip::tcp::resolver resolver( m_hive->GetService() );
	boost::asio::ip::tcp::resolver::query query( host, boost::lexical_cast< std::string >( port ) );
	boost::asio::ip::tcp::endpoint endpoint = *resolver.resolve( query );
	m_acceptor.open( endpoint.protocol() );
	m_acceptor.set_option( boost::asio::ip::tcp::acceptor::reuse_address( false ) );
	m_acceptor.bind( endpoint );
	m_acceptor.listen( boost::asio::socket_base::max_connections );
	StartTimer();
}

boost::shared_ptr< Hive > Acceptor::GetHive()
{
	return m_hive;
}

boost::asio::ip::tcp::acceptor & Acceptor::GetAcceptor()
{
	return m_acceptor;
}

int32_t Acceptor::GetTimerInterval() const
{
	return m_timer_interval;
}

void Acceptor::SetTimerInterval( int32_t timer_interval )
{
	m_timer_interval = timer_interval;
}

bool Acceptor::HasError()
{
	return ( boost::interprocess::detail::atomic_cas32( &m_error_state, 1, 1 ) == 1 );
}

//-----------------------------------------------------------------------------

Connection::Connection( boost::shared_ptr< Hive > hive )
: m_hive( hive ), m_socket( hive->GetService() ), m_io_strand(  hive->GetService() ), m_timer( hive->GetService() ),  m_receive_buffer_size( 4096 ), m_timer_interval( 1000 ), m_error_state( 0  )
{
}

Connection::~Connection()
{
}

void Connection::Bind( const std::string & ip, uint16_t port )
{
	boost::asio::ip::tcp::endpoint endpoint( boost::asio::ip::address::from_string( ip ), port );
	m_socket.open( endpoint.protocol() );
	m_socket.set_option( boost::asio::ip::tcp::acceptor::reuse_address( false ) );
	m_socket.bind( endpoint );
}

void Connection::StartSend()
{
	if( !m_pending_sends.empty() )
	{
		boost::asio::async_write( m_socket, boost::asio::buffer(  m_pending_sends.front() ), m_io_strand.wrap( boost::bind(  &Connection::HandleSend, shared_from_this(),  boost::asio::placeholders::error, m_pending_sends.begin() ) ) );
	}
}

void Connection::StartRecv( int32_t total_bytes )
{
	if( total_bytes > 0 )
	{
		m_recv_buffer.resize( total_bytes );
		boost::asio::async_read( m_socket, boost::asio::buffer(  m_recv_buffer ), m_io_strand.wrap( boost::bind(  &Connection::HandleRecv, shared_from_this(), _1, _2 ) ) );
	}
	else
	{
		m_recv_buffer.resize( m_receive_buffer_size );
		m_socket.async_read_some( boost::asio::buffer( m_recv_buffer ),  m_io_strand.wrap( boost::bind( &Connection::HandleRecv,  shared_from_this(), _1, _2 ) ) );
	}
}

void Connection::StartTimer()
{
	m_last_time = boost::posix_time::microsec_clock::local_time();
	m_timer.expires_from_now( boost::posix_time::milliseconds( m_timer_interval ) );
	m_timer.async_wait( m_io_strand.wrap( boost::bind( &Connection::DispatchTimer, shared_from_this(), _1 ) ) );
}

void Connection::StartError( const boost::system::error_code & error )
{
	if( boost::interprocess::detail::atomic_cas32( &m_error_state, 1, 0 ) == 0 )
	{
		boost::system::error_code ec;
		m_socket.shutdown( boost::asio::ip::tcp::socket::shutdown_both, ec );
		m_socket.close( ec );
		m_timer.cancel( ec );
		OnError( error );
	}
}

void Connection::HandleConnect( const boost::system::error_code & error )
{
	if( error || HasError() || m_hive->HasStopped() )
	{
		StartError( error );
	}
	else
	{
		if( m_socket.is_open() )
		{
			OnConnect( m_socket.remote_endpoint().address().to_string(), m_socket.remote_endpoint().port() );
		}
		else
		{
			StartError( error );
		}
	}
}

void Connection::HandleSend( const boost::system::error_code &  error, std::list< std::vector< uint8_t > >::iterator itr )
{
	if( error || HasError() || m_hive->HasStopped() )
	{
		StartError( error );
	}
	else
	{
		OnSend( *itr );
		m_pending_sends.erase( itr );
		StartSend();
	}
}

void Connection::HandleRecv( const boost::system::error_code & error, int32_t actual_bytes )
{
	if( error || HasError() || m_hive->HasStopped() )
	{
		StartError( error );
	}
	else
	{
		m_recv_buffer.resize( actual_bytes );
		OnRecv( m_recv_buffer );
		m_pending_recvs.pop_front();
		if( !m_pending_recvs.empty() )
		{
			StartRecv( m_pending_recvs.front() );
		}
	}
}

void Connection::HandleTimer( const boost::system::error_code & error )
{
	if( error || HasError() || m_hive->HasStopped() )
	{
		StartError( error );
	}
	else
	{
		OnTimer( boost::posix_time::microsec_clock::local_time() - m_last_time );
		StartTimer();
	}
}

void Connection::DispatchSend( std::vector< uint8_t > buffer )
{
	bool should_start_send = m_pending_sends.empty();
	m_pending_sends.push_back( buffer );
	if( should_start_send )
	{
		StartSend();
	}
}

void Connection::DispatchRecv( int32_t total_bytes )
{
	bool should_start_receive = m_pending_recvs.empty();
	m_pending_recvs.push_back( total_bytes );
	if( should_start_receive )
	{
		StartRecv( total_bytes );
	}
}

void Connection::DispatchTimer( const boost::system::error_code & error )
{
	m_io_strand.post( boost::bind( &Connection::HandleTimer, shared_from_this(), error ) );
}

void Connection::Connect( const std::string & host, uint16_t port)
{
	boost::system::error_code ec;
	boost::asio::ip::tcp::resolver resolver( m_hive->GetService() );
	boost::asio::ip::tcp::resolver::query query( host, boost::lexical_cast< std::string >( port ) );
	boost::asio::ip::tcp::resolver::iterator iterator = resolver.resolve( query );
	m_socket.async_connect( *iterator, m_io_strand.wrap( boost::bind(  &Connection::HandleConnect, shared_from_this(), _1 ) ) );
	StartTimer();
}

void Connection::Disconnect()
{
	m_io_strand.post( boost::bind( &Connection::HandleTimer, shared_from_this(), boost::asio::error::connection_reset ) );
}

void Connection::Recv( int32_t total_bytes )
{
	m_io_strand.post( boost::bind( &Connection::DispatchRecv, shared_from_this(), total_bytes ) );
}

void Connection::Send( const std::vector< uint8_t > & buffer )
{
	m_io_strand.post( boost::bind( &Connection::DispatchSend, shared_from_this(), buffer ) );
}

boost::asio::ip::tcp::socket & Connection::GetSocket()
{
	return m_socket;
}

boost::asio::strand & Connection::GetStrand()
{
	return m_io_strand;
}

boost::shared_ptr< Hive > Connection::GetHive()
{
	return m_hive;
}

void Connection::SetReceiveBufferSize( int32_t size )
{
	m_receive_buffer_size = size;
}

int32_t Connection::GetReceiveBufferSize() const
{
	return m_receive_buffer_size;
}

int32_t Connection::GetTimerInterval() const
{
	return m_timer_interval;
}

void Connection::SetTimerInterval( int32_t timer_interval )
{
	m_timer_interval = timer_interval;
}

bool Connection::HasError()
{
	return ( boost::interprocess::detail::atomic_cas32( &m_error_state, 1, 1 ) == 1 );
}

//-----------------------------------------------------------------------------

???????????????????????????????????????????????Connection?Acceptor?Hive??????????????????????????

???????????????????????????????????????????????????????????????????????echo????

?9a


#include "network.h"
#include 
#include 

boost::mutex global_stream_lock;

class MyConnection : public Connection
{
private:

private:
	void OnAccept( const std::string & host, uint16_t port )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << host << ":" << port << std::endl;
		global_stream_lock.unlock();

		// Start the next receive
		Recv();
	}

	void OnConnect( const std::string & host, uint16_t port )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << host << ":" << port << std::endl;
		global_stream_lock.unlock();

		// Start the next receive
		Recv();
	}

	void OnSend( const std::vector< uint8_t > & buffer )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << buffer.size() << " bytes" << std::endl;
		for( size_t x = 0; x < buffer.size(); ++x )
		{
			std::cout << std::hex << std::setfill( '0' ) << 
				std::setw( 2 ) << (int)buffer[ x ] << " ";
			if( ( x + 1 ) % 16 == 0 )
			{
				std::cout << std::endl;
			}
		}
		std::cout << std::endl;
		global_stream_lock.unlock();
	}

	void OnRecv( std::vector< uint8_t > & buffer )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << buffer.size() << " bytes" << std::endl;
		for( size_t x = 0; x < buffer.size(); ++x )
		{
			std::cout << std::hex << std::setfill( '0' ) << 
				std::setw( 2 ) << (int)buffer[ x ] << " ";
			if( ( x + 1 ) % 16 == 0 )
			{
				std::cout << std::endl;
			}
		}
		std::cout << std::endl;
		global_stream_lock.unlock();

		// Start the next receive
		Recv();

		// Echo the data back
		Send( buffer );
	}

	void OnTimer( const boost::posix_time::time_duration & delta )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << delta << std::endl;
		global_stream_lock.unlock();
	}

	void OnError( const boost::system::error_code & error )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << error << std::endl;
		global_stream_lock.unlock();
	}

public:
	MyConnection( boost::shared_ptr< Hive > hive )
		: Connection( hive )
	{
	}

	~MyConnection()
	{
	}
};

class MyAcceptor : public Acceptor
{
private:

private:
	bool OnAccept( boost::shared_ptr< Connection > connection, const std::string & host, uint16_t port )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << host << ":" << port << std::endl;
		global_stream_lock.unlock();

		return true;
	}

	void OnTimer( const boost::posix_time::time_duration & delta )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << delta << std::endl;
		global_stream_lock.unlock();
	}

	void OnError( const boost::system::error_code & error )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << error << std::endl;
		global_stream_lock.unlock();
	}

public:
	MyAcceptor( boost::shared_ptr< Hive > hive )
		: Acceptor( hive )
	{
	}

	~MyAcceptor()
	{
	}
};

int main( int argc, char * argv[] )
{
	boost::shared_ptr< Hive > hive( new Hive() );

	boost::shared_ptr< MyAcceptor > acceptor( new MyAcceptor( hive ) );
	acceptor->Listen( "127.0.0.1", 7777 );

	boost::shared_ptr< MyConnection > connection( new MyConnection( hive ) );
	acceptor->Accept( connection );

	while( !_kbhit() )
	{
		hive->Poll();
		Sleep( 1 );
	}

	hive->Stop();

	return 0;
}
?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

?9b


#include "network.h"
#include 
#include 

boost::mutex global_stream_lock;

class MyConnection : public Connection
{
private:

private:
	void OnAccept( const std::string & host, uint16_t port )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << host << ":" << port << std::endl;
		global_stream_lock.unlock();

		// Start the next receive
		Recv();
	}

	void OnConnect( const std::string & host, uint16_t port )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << host << ":" << port << std::endl;
		global_stream_lock.unlock();

		// Start the next receive
		Recv();

		std::string str = "GET / HTTP/1.0\r\n\r\n";

		std::vector< uint8_t > request;
		std::copy( str.begin(), str.end(), std::back_inserter( request ) );
		Send( request );
	}

	void OnSend( const std::vector< uint8_t > & buffer )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << buffer.size() << " bytes" << std::endl;
		for( size_t x = 0; x < buffer.size(); ++x )
		{
			std::cout << std::hex << std::setfill( '0' ) << 
				std::setw( 2 ) << (int)buffer[ x ] << " ";
			if( ( x + 1 ) % 16 == 0 )
			{
				std::cout << std::endl;
			}
		}
		std::cout << std::endl;
		global_stream_lock.unlock();
	}

	void OnRecv( std::vector< uint8_t > & buffer )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << buffer.size() << " bytes" << std::endl;
		for( size_t x = 0; x < buffer.size(); ++x )
		{
			std::cout << std::hex << std::setfill( '0' ) << 
				std::setw( 2 ) << (int)buffer[ x ] << " ";
			if( ( x + 1 ) % 16 == 0 )
			{
				std::cout << std::endl;
			}
		}
		std::cout << std::endl;
		global_stream_lock.unlock();

		// Start the next receive
		Recv();
	}

	void OnTimer( const boost::posix_time::time_duration & delta )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << delta << std::endl;
		global_stream_lock.unlock();
	}

	void OnError( const boost::system::error_code & error )
	{
		global_stream_lock.lock();
		std::cout << "[" << __FUNCTION__ << "] " << error << std::endl;
		global_stream_lock.unlock();
	}

public:
	MyConnection( boost::shared_ptr< Hive > hive )
		: Connection( hive )
	{
	}

	~MyConnection()
	{
	}
};

int main( int argc, char * argv[] )
{
	boost::shared_ptr< Hive > hive( new Hive() );

	boost::shared_ptr< MyConnection > connection( new MyConnection( hive ) );
	connection->Connect( "www.google.com", 80 );

	while( !_kbhit() )
	{
		hive->Poll();
		Sleep( 1 );
	}

	hive->Stop();

	return 0;
}
???????Google??HTTP GET?????????????????????????????????????????????????????????????????????????????????????????????????????????

???????????????????????????????????????????????????????“???”????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????HTTP??????????????????????????

????????????????????????????????strand?????????????????????????????????????????????????????????????????????????????????????????????????????????????????

?????/??????????????????????????????????????????????????????????????????????????????????????????????????????????C ++???????????????????

?????????????????????boost::asio????????????????????????????????????????????????????????????????boost::asio??

[?]

????
?????????????????

????boost?boost::asio?????????????????
????boost::asio??????????????????????????????????
????????????????????????????
???????????????boost::asio???????boost::asio???????????????????????????????????????????????????????????????boost::asio????????????boost::asio?????????????????????boost::asio???????????????????????????????????????????????????

UDP??TCP????????????????????????????????UDP??????????????????UDP????????TCP API????UDP??API??????????????????????UDP????????????TCP??????????????????????????????????UDP???????????????????????

?????3?????????????????“???”?????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????

???????????????boost::asio??????????????????????????????????????????????boost::asio?????????boost :: bind????????????????????????“??”??????????????????????????????????????????API??

?????????boost::asio?????????????????????????????????????11

30??1 2????1???2?

Imgelling Imgelling 222???2011?2?2?

????????????????????????????????????boost?asio for networking????????????????1 TTHTTH 106 2011?2?2???

???????????????boost::asio??????????????????????????“??vs??”??????????????????????????????????4b?????... [code] io_service-> post?strand.wrap?boost :: bind??PrintNum?1?? ?; [/ code] ...???... [code] strand.post?boost :: bind??PrintNum?1??; [/ code] ...?????2 Drew_Benton Drew_Benton 1862???2011?2?2?

[quote name ='TTH'timestamp ='1296588474']???????????????boost::asio??????????????????????????“??vs??”??????????????????????????????????4b?????... [code] io_service-> post?strand.wrap?boost :: bind??PrintNum?1?? ?; [/ code] ...???... [code] strand.post?boost :: bind??PrintNum?1??; [/ code] ...?????[/??]

?????????????????????????????????????????????????????

???????????????????????????????????????????????????????????????????????????????????????????????

[quote]?????????

async_op_1?...?s.wrap?a??; async_op_2?...?s.wrap?b?;?????????????s.dispatch?a????????s.dispatch?b???????????????????????????????????????????????????????????

[/??]

???4b??async_op_1??“io_service-> post?strand.wrap?boost :: bind??PrintNum?1???;”??async_op_2??“io_service-> post?strand.wrap?boost :: bind??PrintNum? ?2???;“??????20/20????????????????????????????????????????????????????????????????????:)?? Homer Homer 58???2011?2?5?

?!! ????????:)

?????Windows IOCP api?????IOCP??????????????eventink??????????????????????????iocp?????????......

????????????????????????????????????????????? - ???????????Hive???????MyHive??????????????????

??????????????????????????????????????????????????????????????socksv4?????????????????;? ?? ?? 58???2011?2?5??

???????????

????????????????18???????12???? - ????????????????????18????
???OnSend?OnRecv????????“??????”????????????????18???????
??????????????????????????????????????????????

???????????????????????

Homer Homer 58???2011?2?5?

????MyConnection.OnRecv?OnSend?????????
        std :: cout <<“[”<< FUNCTION <<“]”<< buffer.size??<<“bytes”<< std :: endl; 

????
        char blah [50]; 
        sprintf_s?blah?“?d bytes \ n”?buffer.size???; 
?; std :: cout <<“[”<< FUNCTION <<“]”<< blah; 

?????????'?????'?

?????????????????????

Drew_Benton Drew_Benton 1862???2011?2?8?

[quote]?????????????????????????[/ quote]

???????9b?????????????????????????;?????????????????????????????????Windows???????????????????????????????????????????????

[quote]???????????????????? - ???????????Hive???????MyHive?????????????????[/ quote]

???????????????????????Hive??????????????????????????????????????????boost :: dynamic_pointer_cast?shared_ptr???????????

[quote]??????????????????????????????????????????????????????????????socksv4????????????????;?[/ quote]

??????????????????????????????????????????????????????????????????????????????????????????????????????Rutix Rutix 112???2011?3?21?

??? ????????????????????????????????????????????:) Emmanuel Deloget Emmanuel Deloget 1381???2011?9?1?

????????????????????PDF????????FrEEzE2046 FrEEzE2046 106???2011?9?12?

????????????????????boost::asio???????????????????????????????????????????????????????????????????????

[code] #include <boost / asio.hpp> #include <boost / bind.hpp> #include <boost / shared_ptr.hpp> #include <boost / thread.hpp> #include <boost / thread / mutex.hpp>

???

void worker_thread?boost::asio :: io_service??boost :: mutex??;

int main??{boost :: mutex mutex; boost::asio :: io_service io_service; boost::asio :: io_service :: work work?io_service?;

//??????????????std::cout???????????//??????std :: cout«“thread [”«boost :: this_thread :: get_id??«“]?[???]???“«std :: endl;

boost :: thread_group worker_threads; for?int i = 0; i <4; ++ i?{//??????????worker_thread????????????????boost :: bind?????????????????????????//??boost :: ref?boost :: cref??????reference_wrapper??//??????????????????????//???????worker_threads.create_thread?boost :: bind?worker_thread?boost :: ref?io_service??boost :: ref?mutex???; }

//????????????????????worker_thread??????????????????

?std :: cin.get??;

io_service.stop??;

worker_threads.join_all??;

??0; }

void worker_thread?boost::asio :: io_service?io_service?boost :: mutex?mutex?{{//??????lock_guard????????????????????????:: lock_guard?????; std :: cout <<“thread [”<< boost :: this_thread :: get_id??<<“] start”<< std :: endl; }

io_service.run??;

{boost :: lock_guard?????; std :: cout <<“thread [”<< boost :: this_thread :: get_id??<<“]??”<< std :: endl; } / [code] Nanook Nanook 537???2012?4?30?

????

???????????????????boost???asio io_service???????????????????????..??3????????????????boost????????????????????????..??????????????????????.. ilbardosilente ilbardosilente 101???2012?7?7?

?????????????????

????105???2012?9?30?

????????2e???????std?ref????????????

[CODE] void WorkerThread?boost::asio :: io_service?io_service?{std :: cout«“Thread Start \ n”; io_service.run??; std :: cout«“Thread Finish \ n”; } int main?int argc?char ** argv?{boost::asio :: io_service io_service; boost::asio :: io_service :: work work?io_service?; std :: cout«“?[return]???”«std :: endl; boost :: thread_group worker_threads; for?int x = 0; x <4; ++ x?{worker_threads.create_thread?boost :: bind??WorkerThread?std :: ref?io_service???; } std :: cin.get??; io_service.stop??; worker_threads.join_all??; ??0; } [/ CODE]??105???2012?10?1?

?????8a???????????howie_007 howie_007 285???2012?10?22?

????????????????????????????????????????????Boost????????????????????????????????????????????????????????lucastamoios lucastamoios 104???2012?12?30?

???????boost.asio??????????????????????????????????????????????????????????????????????????????????????????? - ??????????

???

mwpowellhtx mwpowellhtx 106???2013?2?14?

????????????????C ++?????????????????????????????????????????????????????????????????“????”??????????????????????????????????????Windows?????

??????????????io_service??????????????????????????????????????IO????????????????Asio???

??......??????“??”?“?”?????????????????????????????????????????????????????????????????????????????????????????????

?????????????????????????

mwpowellhtx mwpowellhtx 106???2013?2?14?

??????????????????????????????????????“?????????????????io_service?????????????” ??????????????????????????

???????“??”???????????????????????????????????????????????????????????

????????2e???????std?ref????????????

void WorkerThread?boost::asio :: io_service?io_service?{std :: cout«“Thread Start \ n”; io_service.run??; std :: cout«“Thread Finish \ n”; } int main?int argc?char ** argv?{boost::asio :: io_service io_service; boost::asio :: io_service :: work work?io_service?; std :: cout«“?[return]???”«std :: endl; boost :: thread_group worker_threads; for?int x = 0; x <4; ++ x?{worker_threads.create_thread?boost :: bind??WorkerThread?std :: ref?io_service???; } std :: cin.get??; io_service.stop??; worker_threads.join_all??; ??0; } 1 mwpowellhtx mwpowellhtx 106???2013?2?14?

?! ?????????????????????????????????????io_service?????????????????????????????io_service??????????????????????

mwpowellhtx mwpowellhtx 106???2013?2?14?

??8??????????boost::asio :: ip :: tcp :: resolver :: query???????7a??????????????????????DHCP?????IP?????????????????80?????????????????????????“??”????????“??”??????

mwpowellhtx mwpowellhtx 106???2013?2?15?

????????????????????????boost :: bind????????????????????????????????????IPC?????????????????????void async_socket_client :: connect?const boost::asio :: ip :: tcp :: endpoint?ep?{//?Socket???????????TCP / IP???m_sp_socket-> async_connect?ep?boost :: bind?async_socket_client :: connected?_1?m_sp_socket??;}??connected??????shared_ptr???????boost :: shared_ptrsp_socket???{/*...*/}?????????????????????????????????????????????????????????1??C3867?'our :: io :: socket_client_base :: connected'???????????; ??'?our :: io :: socket_client_base :: connected'??????c?\ source \ our \ device \ our-device \ our-asio \ async_socket_client.cpp???22 1 our-asio

???????????????????boost :: bind?????????????????????????????????????????????????????????????????????????????

?????????????????????????????????????????Visual Studio 2010 SP1???????C / C ++????????????

???????????????????????????????????????????????????????????????error_code????OnConnect??????????mwpowellhtx mwpowellhtx 106???2013?2?15?

????????????????????????boost :: bind????????????????????????????????????IPC?????????????????????void async_socket_client :: connect?const boost::asio :: ip :: tcp :: endpoint?ep?{//?Socket???????????TCP / IP???m_sp_socket-> async_connect?ep?boost :: bind?async_socket_client :: connected?_1?m_sp_socket??;}??connected??????shared_ptr?virtual void connected?boost :: shared_ptr sp_socket?override {/ .../}??????????????????????????????????????????????????????????1??C3867?'???:: io? ?socket_client_base :: connected'???????????; ??'?our :: io :: socket_client_base :: connected'??????c?\ source \ our \ device \ our-device \ our-asio \ async_socket_client.cpp???22 1 our-asio??????????????????boost :: bind?????????????????????????????????????????????????????????????????????????????????????????????????????????????????Visual Studio 2010 SP1???????C / C ++???????????????????????????????????????????????????????????????????????????error_code????OnConnect??????????mwpowellhtx mwpowellhtx 106???2013?2?15?

???????????????????error_code?????????????????????

Shenjoku Shenjoku 161???2013?9?1?

???????????+?????????????????127.0.0.1:8888??????????????????????????????????????????????????????????????????

pnraj pnraj 110???2015?5?11?

????????????????????????????????????????????????????????????????????????????????????

?????2e???????int????????

Boost doc???“int x”??????????????????????????????????????????????“myThreadnum”???

???????????????????????????/???????????runnables???

void WorkerThread?boost::asio :: io_service?io_service?int x?{int myThreadNum = x;

int myThread-num = i;

std :: cout«“Thread Start \ n”; io_service.run??; std :: cout«“Thread Finish \ n”; } int main?int argc?char ** argv?{boost::asio :: io_service io_service; boost::asio :: io_service :: work work?io_service?; std :: cout«“?[return]???”«std :: endl; boost :: thread_group worker_threads; for?int x = 0; x <4; ++ x?{worker_threads.create_thread?boost :: bind??WorkerThread?std :: ref?io_service?x???; } std :: cin.get??; io_service.stop??; worker_threads.join_all??; ??0; }

?????

1 2 NEXT?1???2?
???????????????????????????

??????????????????????

??????????????

??

??????khawk????????????????khawk

 37 khawk	 Ping, Zap, Zing! Side Scrolling Arcade Shooter Challenge - Without Weapons! By khawk in Challenges

 19 FatPugStudio	 Perspective of living as an indie dev in my country By FatPugStudio in Rick Henderson And The Artifact Of Gods

 12 Rutin	 Mr Boom's Shipping Container By Rutin in Art work

 8 Rutin	 Challenge 1 - 3D Chess - Part 1 By Rutin in Game Challenges

 8
??GDNet??????
??...

????????????????????????boost::asio GameDev.net?????????????????????GameDev??GameDev???????????????????????

????©1999-2019 GameDev.net?LLC

Noob???
Noob???
shiyanhk@gmail.com
 harkhuang
 harkWONG
??????????????????????_config.yml????????????????????Google????????feed.xml??????
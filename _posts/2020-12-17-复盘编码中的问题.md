---
layout: post
title:  "review一年前的代码"
date:   2020-12-17 15:07:51 +0800
categories: jekyll update
---


 ### 使用成员变量 在异步中共享数据

在复盘代码中再次领教到了vs编译器强大之处,几乎你想要功能在里面都可以找到,
比如类地址,当前断点线程id,比如查看某段内存内容,条件断点,回退断点,调试起来速度和性能真实优秀,而且能解决大部分开发商的效率问题,实属强大.

在没有领教到vs强大之处的时候,在使用其他ide的时候总是对windows一切程序呈现出批判态度,我认为事物是辩证的,正如博弈论中的所讲"我只要比你跑得快.我就不会被狮子吃掉."
如果凡事绝对的去判断对错,妄加判断,会对自己的判断造成影响和后续的实践成本增加较大代价.


回归正题:


遇到的几个问题11总结.

现象:
线程A写数据,线程B(call_back)回调函数却拿不到该数据,线程AB同属于一个对象.
内部对象在成员变量共享的时候总是不能同步,怀疑是对象构建出了问题,一定是有两个对象,所以才造成了这个问题.
.在很多次调试以后,总是遇到这个问题,因为多线程数据共享,没有比类成员变量更简单的方式了.
无奈只能在外部给对象做一个全局的共享.同时使用extern引用这个全局的变量.

实践:
1.对象不一致?
2.异步共享数据时候有系统做优化,例如volatile.
3.有刁民总是在修改朕的代码.



通过vs定位 &map地址  定位对象地址
![avatar](/home/picture/immediate_windows.png)

线程id:0x00003DB4
map  外部全局
0x000002486126eba8
map 成员变量
0x0000024863570f40

线程id: 0x00004920
map write 0x000002486126eba8
map read 0x0000024863565b20

=>确认了是对象不同造成的数据不能同步 

=>疯狂找原因, 确实在初始化的时候做了两次new对象操作.深究其具体原因 ,就是因为没有对第三方库给定的api一个正确的定位和使用方式.

=>最终调整new对象  利用this做二次识别定位  解决了这个问题

原因:
在外部提供的接口中可以对回调做绑定. 三方库函数写的模糊同时写代码时候也没有注意到这个问题. 
这就是技术债吧


 ### 使用promise异步共享数据 

 具体看了下cpprefrence的语法  均使用std::move进行promise参数传入,在线程异步中 仅仅做值传递应该满足不了我们的要求, 异步操作不能识别这个对象.

 ###  消费者总是重复接受到第一条消息

 本以为是结构问题,但是通过代码review后发现,是因为在最初使用stl没有对容器做清除,导致后续读取操作总是在读第一条数据.